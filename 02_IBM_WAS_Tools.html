<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=-wDXL3w4Eh8e-nbTunW3Bg');ol{margin:0;padding:0}table td,table th{padding:0}.c12{border-right-style:solid;padding:3.8pt 3.8pt 3.8pt 3.8pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:middle;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#eeeeee;border-left-style:solid;border-bottom-width:1pt;width:430.5pt;border-top-color:#000000;border-bottom-style:solid}.c14{border-right-style:solid;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:middle;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:432pt;border-top-color:#000000;border-bottom-style:solid}.c27{margin-left:4.5pt;padding-top:4.5pt;text-indent:-4.5pt;padding-bottom:14pt;line-height:1.0;page-break-after:avoid;text-align:left;margin-right:4.5pt}.c0{background-color:#ffffff;color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c10{margin-left:4.5pt;padding-top:4.5pt;text-indent:-4.5pt;padding-bottom:14pt;line-height:1.0;page-break-after:avoid;text-align:center;margin-right:4.5pt}.c9{background-color:#ffffff;color:#000000;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c22{margin-left:-3.8pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c19{padding-top:0pt;padding-bottom:14pt;line-height:1.0;text-align:center}.c17{margin-left:0.5pt;border-spacing:0;border-collapse:collapse;margin-right:auto}.c1{padding-top:0pt;padding-bottom:14pt;line-height:1.0;text-align:justify}.c5{padding-top:0pt;padding-bottom:14pt;line-height:1.0;text-align:left}.c13{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:justify}.c24{background-color:#ffffff;max-width:432pt;padding:72pt 90pt 72pt 90pt}.c16{font-family:"Verdana";font-weight:400}.c23{font-family:"Cardo";font-weight:400}.c18{font-weight:400;font-family:"Courier New"}.c2{font-size:10pt;font-weight:700}.c7{color:#800000}.c21{height:0pt}.c6{color:#0000ff}.c15{height:12pt}.c26{font-family:"Verdana"}.c20{color:#ff0000}.c11{font-size:10pt}.c8{font-style:italic}.c25{vertical-align:super}.c4{font-weight:700}.title{background-color:#ffffff;padding-top:24pt;color:#000000;font-weight:700;font-size:36pt;padding-bottom:6pt;font-family:"Times New Roman";line-height:1.0;page-break-after:avoid;text-align:left}.subtitle{background-color:#ffffff;padding-top:18pt;color:#666666;font-size:24pt;padding-bottom:4pt;font-family:"Georgia";line-height:1.0;page-break-after:avoid;font-style:italic;text-align:left}li{background-color:#ffffff;color:#000000;font-size:12pt;font-family:"Times New Roman"}p{background-color:#ffffff;margin:0;color:#000000;font-size:12pt;font-family:"Times New Roman"}h1{background-color:#ffffff;padding-top:4.5pt;color:#000000;font-weight:700;font-size:18pt;padding-bottom:4.5pt;font-family:"Times New Roman";line-height:1.0;page-break-after:avoid;text-align:left}h2{background-color:#ffffff;padding-top:4.5pt;color:#000000;font-weight:700;font-size:14pt;padding-bottom:4.5pt;font-family:"Times New Roman";line-height:1.0;page-break-after:avoid;font-style:italic;text-align:left}h3{background-color:#ffffff;padding-top:4.5pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:4.5pt;font-family:"Times New Roman";line-height:1.0;page-break-after:avoid;text-align:left}h4{background-color:#ffffff;padding-top:4.5pt;color:#000000;font-weight:700;font-size:10pt;padding-bottom:4.5pt;font-family:"Times New Roman";line-height:1.0;page-break-after:avoid;text-align:left}h5{background-color:#ffffff;padding-top:4.5pt;color:#000000;font-weight:700;font-size:8pt;padding-bottom:4.5pt;font-family:"Times New Roman";line-height:1.0;page-break-after:avoid;font-style:italic;text-align:left}h6{background-color:#ffffff;padding-top:4.5pt;color:#000000;font-weight:700;font-size:8pt;padding-bottom:4.5pt;font-family:"Times New Roman";line-height:1.0;page-break-after:avoid;text-align:left}</style></head><body class="c24"><p class="c5"><span class="c0">Type of analysis tools </span></p><p class="c3"><span class="c0">Tool #1: IBM Trace and Request Analyzer for WebSphere Application Server </span></p><p class="c3"><span class="c0">Tool #3: IBM Web Server Plug-in Analyzer for WebSphere Application Server </span></p><p class="c5" id="h.gjdgxs"><span class="c0">Tool #2: IBM HeapAnalyzer <br>Tool #6: Database Connection Pool Analyzer for IBM WebSphere Application Server. Tool #5: IBM Thread and Monitor Dump Analyzer for Java Technology <br>Tool #4: IBM Pattern Modeling and Analysis Tool for Java Garbage Collector </span></p><p class="c5" id="h.30j0zll"><span class="c0"><br>test</span></p><h3 class="c10"><span class="c7 c8">Tool # 1</span><span class="c9 c4">&nbsp;</span></h3><h3 class="c10"><span class="c7">IBM Trace and Request Analyzer for WebSphere Application Server</span><span class="c9 c4">&nbsp;</span></h3><p class="c19"><span class="c7">(tra21.zip)</span><span class="c0">&nbsp;</span></p><h3 class="c27" id="h.1fob9te"><span class="c7 c11 c8"><br></span><span class="c7 c8">What is IBM Trace and Request Analyzer for WebSphere Application Server? </span></h3><p class="c1"><span class="c0">WebSphere&reg; Application Server trace is used to obtain detailed information about running components, including application servers, clients, and other processes in the environment, such as the time and sequence of methods called by the base classes. </span></p><p class="c1"><span class="c0">IBM&reg; Trace and Request Analyzer for WebSphere Application Server allows you to find delays and possible hangs from WebSphere trace files and HTTP plug-in traces by parsing call trees of methods and traces and calculating delays in each method and trace. </span></p><p class="c1"><span class="c0">The package includes a Java&trade; graphical user interface (GUI) application that displays delays in lists and tables. </span></p><p class="c5"><span class="c7 c4">How does it work?</span><span class="c0">&nbsp;</span></p><p class="c5"><span class="c0">The tool can be used on an &quot;as needed&quot; basis, as follows: </span></p><p class="c13"><span class="c0">The user defines and puts in the threshold in order to find delays in trace longer than the threshold. </span></p><p class="c3"><span class="c0">The tool reads WebSphere Application Server trace files or HTTP plug-in trace files. </span></p><p class="c1"><span class="c0">The tool parses method call tree, time stamp, process ID, thread ID, trace entry, trace exit, method entry and method exit information according to the following steps: </span></p><p class="c13"><span class="c0">The user customizes the parsing information, if desired. </span></p><p class="c13"><span class="c0">The tool calculates actual times spent in each method and trace. </span></p><p class="c13"><span class="c0">The tool finds delays longer than the threshold. </span></p><p class="c13"><span class="c0">The tool sorts the delay list by delay time. </span></p><p class="c1"><span class="c0">The tool displays a list of delays and trace entries on the GUI. </span></p><p class="c5"><span class="c2 c8"><br></span><span class="c7 c8 c4">Installation instructions </span></p><p class="c5"><span class="c11 c8">Run traNNN.jar with the Java Run-time Environment (NNN is the version number). The following is an example of a command for processing a javacore with IBM Trace and Request Analyzer for WebSphere Application Server, Version 1.0, and about 500 MB of Java heap size: </span></p><a id="t.8ede26dceefe215e4e7f85f4cd812b0e70becb1d"></a><a id="t.0"></a><table class="c17"><tbody><tr class="c21"><td class="c14" colspan="1" rowspan="1"><p class="c3"><span class="c18">&lt;Java Runtime Environment path&gt;java -Xmx500m -jar tra10.jar </span></p></td></tr></tbody></table><p class="c5"><span><br></span><span class="c4 c6">Which log file i have to use :</span><span class="c0">&nbsp;</span></p><p class="c5 c15"><span class="c0"><br></span></p><h3 class="c10"><span class="c7 c8">Tool # 2</span><span class="c9 c4">&nbsp;</span></h3><p class="c19"><span class="c7">IBM HeapAnalyzer</span><span class="c0">&nbsp;</span></p><p class="c19"><span class="c7">ha26.zip</span><span class="c0">&nbsp;</span></p><p class="c5"><span class="c7 c8 c4">What is HeapAnalyzer?</span><span class="c7 c8">&nbsp;</span></p><p class="c5 c15"><span class="c0"><br></span></p><p class="c1"><span class="c6 c8">You have to generate the HeapDump.. This is different from Thread dump, you have to configure certain parameters and then only you can generate this HeapDump.</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c8">HeapAnalyzer allows the finding of a possible Java&trade; heap leak area through its heuristic search engine and analysis of the Java</span><span class="c8 c25">TM</span><span class="c8">&nbsp;heap dump in Java applications. </span></p><p class="c1"><span class="c0">Java heap areas define objects, arrays, and classes. When the Garbage Collector allocates areas of storage in the heap, an object continues to be live while a reference to it exists somewhere in the active state of the JVM; therefore the object is reachable. When an object ceases to be referenced from the active state, it becomes garbage and can be reclaimed for reuse. When this reclamation occurs, the Garbage Collector must process a possible finalizer and also ensure that any internal JVM resources that are associated with the object are returned to the pool of such resources. Java heap dumps are snap shots of Java heaps at specific times. </span></p><p class="c5"><span class="c7 c4">How does it work?</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">HeapAnalyzer analyzes Java heap dumps by parsing the Java heap dump, creating directional graphs, transforming them into directional trees, and executing the heuristic search engine. </span></p><p class="c1"><span class="c0">The following are examples of features: </span></p><p class="c3"><span class="c0">List of Java heap leak suspects </span></p><p class="c3"><span class="c0">Recommendation of the size of kCluster </span></p><p class="c3"><span class="c0">List of gaps among allocated objects/classes/arrays </span></p><p class="c3"><span class="c0">Java objects/classes/arrays search engine </span></p><p class="c3"><span class="c0">List of objects/classes/arrays by type name </span></p><p class="c3"><span class="c0">List of objects/classes/arrays by object name </span></p><p class="c3"><span class="c0">List of objects/classes/arrays by address </span></p><p class="c3"><span class="c0">List of objects/classes/arrays by size </span></p><p class="c3"><span class="c0">List of objects/classes/arrays by size of child </span></p><p class="c3"><span class="c0">List of objects/classes/arrays by number of child </span></p><p class="c3"><span class="c0">List of objects/classes/arrays by frequency </span></p><p class="c3"><span class="c0">List of available heap spaces by size </span></p><p class="c3"><span class="c0">Tree view of Java heap dump </span></p><p class="c5"><span class="c0">Loading/saving processed Java heap dumps. </span></p><p class="c5"><span class="c8 c11">The following is an example of processing a Java&trade; heap dump of about 1 GB: </span></p><a id="t.d03b2db5078e70bdda2de532d07b039c7ebedb3f"></a><a id="t.1"></a><table class="c22"><tbody><tr class="c21"><td class="c12" colspan="1" rowspan="1"><p class="c3"><span class="c18">&lt;Java Runtime Environment path&gt;java -Xmx1200m -jar ha121.jar </span></p></td></tr></tbody></table><p class="c5 c15"><span class="c0"><br></span></p><p class="c5"><span class="c6 c4">Which log file i have to use :</span><span class="c0"><br></span></p><p class="c5 c15"><span class="c0"><br></span></p><h3 class="c10"><span class="c7 c8">Tool # 3</span><span class="c9 c4">&nbsp;</span></h3><p class="c19"><span class="c7 c8">IBM Web Server Plug-in Analyzer for WebSphere Application Server</span><span class="c0">&nbsp;</span></p><p class="c19"><span class="c7 c8">wspa22.zip</span><span class="c0">&nbsp;</span></p><p class="c1 c15"><span class="c0"><br></span></p><p class="c1"><span class="c7 c8 c4">What is IBM Web Server Plug-in Analyzer for WebSphere Application Server?</span><span class="c7 c8">&nbsp;</span></p><p class="c1"><span class="c6 c8">This tool just uses the plugin configuration file plugin-cfg.xml</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">IBM&reg; Web Server Plug-in Analyzer for WebSphere&reg; Application Server helps discover potential problems with trace and configuration files during use of WebSphere Application Server. The tool parses both plug-in configuration and corresponding trace files and then applies pattern recognition algorithms in order to alert users of possible inconsistencies. </span></p><p class="c1"><span class="c0">The tool provides a list of HTTP return codes, URI and graphical presentations of available clusters, and server topologies from the configuration and trace files. </span></p><p class="c1"><span class="c0">The primary automatic capabilities of this tool are as follows: </span></p><p class="c13"><span class="c0">detection of incorrect or potentially problematic configurations that could cause service interruption or performance degradation </span></p><p class="c13"><span class="c0">identification of request failure or response failure </span></p><p class="c13"><span class="c0">HTTP return code tracking </span></p><p class="c13"><span class="c0">URI failure tracking </span></p><p class="c13"><span class="c0">graphical presentation of WebSphere Application Server and cluster topology </span></p><p class="c1"><span class="c0">cluster and cluster member tracking. </span></p><p class="c1"><span class="c0">The package includes the stand-alone code, documentation, and license files. </span></p><p class="c1"><span class="c7 c4">How does it work?</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">The tool parses WebSphere Application Server plug-in configuration files and trace files. Based on results obtained from a pattern recognition engine, IBM Web Server Plug-in Analyzer provides information about any potential problems within the configuration. </span></p><p class="c1"><span class="c0">The pattern recognition engine maintains various patterns of configurations that are not usually recommended and provides warnings if these same patterns are detected in the configuration files. </span></p><p class="c1"><span class="c0">The tool takes the following approach: </span></p><p class="c13"><span class="c0">It parses configuration files. </span></p><p class="c13"><span class="c0">It provides warnings or clues to information when configurations appear to be set inappropriately. </span></p><p class="c13"><span class="c0">It collects WebSphere Application Server cluster and member topology information within the configuration file. </span></p><p class="c13"><span class="c0">It displays a visual mapping of the cluster and member topology. </span></p><p class="c13"><span class="c0">It parses the plug-in trace files and creating models based on HTTP request/response header/body information, HTTP return code, URI, start/end time, cluster name, and server name. </span></p><p class="c1"><span class="c0">It displays the requested trace information based on query. The trace information has HTTP return code analysis and HTTP request/response header/body analysis. </span></p><p class="c1 c15"><span class="c0"><br></span></p><p class="c1"><span class="c8">Run wspaNNN.jar with the Java Run-time Environment (NNN is the version number). </span></p><p class="c1"><span>The following is an </span><span class="c4">example</span><span class="c0">&nbsp;of a command with IBM Web Server Plug-in Analyzer for WebSphere Application Server, Version 1.0, and about 500 MB of Java heap size: </span></p><a id="t.157e9a526e636c5547838895ca52fe7e275a8bc7"></a><a id="t.2"></a><table class="c17"><tbody><tr class="c21"><td class="c14" colspan="1" rowspan="1"><p class="c13"><span>&lt;Java Runtime Environment path&gt;java -Xmx500m -jar wspa10.jar</span><span class="c18">&nbsp;</span></p></td></tr></tbody></table><p class="c1"><span class="c6 c4">Which log file i have to use : </span><span class="c4 c20">plugin-cfg.xml</span><span class="c0">&nbsp;</span></p><p class="c3 c15"><span class="c0"></span></p><p class="c3 c15"><span class="c0"></span></p><h3 class="c10"><span class="c7 c8">Tool # 4</span><span class="c9 c4">&nbsp;</span></h3><p class="c19"><span class="c7 c8">IBM Pattern Modeling and Analysis Tool for Java Garbage Collector</span><span class="c0">&nbsp;</span></p><p class="c19"><span class="c7 c8">(ga24.zip)</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c7 c8 c4">What is Pattern Modeling and Analysis Tool for IBM Java Garbage Collector?</span><span class="c7 c8">&nbsp;</span></p><p class="c1"><span class="c6 c8">This is done using the native_error.log and native_access.log files...? the native_error.log file contains the memory usage too. </span><span class="c6 c8 c4">Enable verbose Garbage Collector..</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">Pattern Modeling and Analysis Tool for IBM&reg; Java&trade; Garbage Collector (PMAT) parses verbose GC trace, analyzes Java heap usage, and recommends key configurations based on pattern modeling of Java heap usage. </span></p><p class="c1"><span class="c0">When the JVM (Java virtual machine) cannot allocate an object from the current heap because of lack of space, a memory allocation fault occurs, and the Garbage Collector is invoked. The first task of the Garbage Collector is to collect all the garbage that is in the heap. This process starts when any thread calls the Garbage Collector either indirectly as a result of allocation failure or directly by a specific call to System.gc(). The first step is to get all the locks needed by the garbage collection process. This step ensures that other threads are not suspended while they are holding critical locks. All other threads are then suspended. Garbage collection can then begin. It occurs in three phases: Mark, Sweep, and Compaction (optional). </span></p><p class="c1"><span>Verbose GC is a command-line option that one can supply to the JVM at start-up time. The format is: </span><span class="c4">-verbose:gc</span><span>&nbsp;or </span><span class="c4">-verbosegc.</span><span class="c0">&nbsp;This option switches on a substantial trace of every garbage collection cycle. The format for the generated information is not designed and therefore varies among various platforms and releases. </span></p><p class="c1"><span class="c0">This trace should allow one to see the gross heap usage in every garbage collection cycle. For example, one could monitor the output to see the changes in the free heap space and the total heap space. This information can be used to determine whether garbage collections are taking too long to run; whether too many garbage collections are occurring; and whether the JVM crashed during garbage collection. </span></p><p class="c1"><span class="c4">How does it work?</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">PMAT analyzes verbose GC traces by parsing the traces and building pattern models. PMAT recommends key configurations by executing a diagnosis engine and pattern modeling algorithm. If there are any errors related with Java heap exhaustion or fragmentation in the verbose GC trace, PMAT can diagnose the root cause of failures. PMAT provides rich chart features that graphically display Java heap usage. </span></p><p class="c1"><span class="c0">The following features are included: </span></p><p class="c13"><span class="c0">GC analysis </span></p><p class="c13"><span class="c0">GC table view </span></p><p class="c13"><span class="c0">Allocation failure summary </span></p><p class="c13"><span class="c0">GC usage summary </span></p><p class="c13"><span class="c0">GC duration summary </span></p><p class="c13"><span class="c0">GC graph view </span></p><p class="c13"><span class="c0">GC pattern analysis </span></p><p class="c13"><span class="c0">Zoom in/out/selection/center of chart view </span></p><p class="c1"><span class="c0">Option of changing chart color. </span></p><p class="c1"><span class="c2 c8">Installation instructions</span><span class="c11 c8">&nbsp;</span></p><p class="c13"><span>Unzip gaNNN.zip (</span><span class="c8">NNN</span><span class="c0">&nbsp;is the version number). </span></p><p class="c13"><span class="c0">Unzip readmeNNN.zip and read the readme file. </span></p><p class="c1"><span class="c0">Run gaNNN.jar with the Java Run-time Environment. </span></p><p class="c1"><span class="c0">The following is an example of processing a verbose GC trace with PMAT Version 1.0.1 and about 500 MB of Java heap size: </span></p><a id="t.2010d3b0181f4b999e481bab9c49e0e12c893f96"></a><a id="t.3"></a><table class="c17"><tbody><tr class="c21"><td class="c14" colspan="1" rowspan="1"><p class="c3"><span class="c18">&lt;Java Runtime Environment path&gt;java -Xmx500m -jar ga101.jar </span></p></td></tr></tbody></table><p class="c5"><span><br></span><span class="c6 c4">Which log file i have to use :</span><span class="c0">&nbsp;</span></p><p class="c5 c15"><span class="c0"><br></span></p><p class="c5 c15"><span class="c0"><br></span></p><h3 class="c10"><span class="c7 c8">Tool # 5</span><span class="c9 c4">&nbsp;</span></h3><p class="c19"><span class="c7 c8">IBM Thread and Monitor Dump Analyzer for Java Technology</span><span class="c0">&nbsp;</span></p><p class="c19"><span class="c7 c8">(jca26.zip)</span><span class="c0">&nbsp;</span></p><p class="c1 c15"><span class="c0"><br></span></p><p class="c1"><span class="c2 c7 c8">What is IBM Thread and Monitor Dump Analyzer for Java Technology?</span><span class="c7 c11 c8">&nbsp;</span></p><p class="c1"><span class="c6 c11 c8">You have to generate the Thread Dump using the commands... Check the last page regarding that.</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">During the run time of a Java&trade; process, some Java Virtual Machiness (JVMs) may not respond predictably and oftentimes seem to hang up for a long time or until JVM shutdown occurs. It is not easy to determine the root cause of these sorts of problems. </span></p><p class="c1"><span>By triggering a </span><span class="c8">javacore</span><span class="c0">&nbsp;when a Java process does not respond, it is possible to collect diagnostic information related to the JVM and a Java application captured at a particular point during execution. For example, the information can be about the operating system, the application environment, threads, native stack, locks, and memory. The exact contents are dependent on the platform on which the application is running. </span></p><p class="c1"><span class="c0">On some platforms, and in some cases, javacore is known as &quot;javadump.&quot; The code that creates javacore is part of the JVM. One can control it by using environment variables and run-time switches. By default, a javacore occurs when the JVM terminates unexpectedly. A javacore can also be triggered by sending specific signals to the JVM. Although javacore or javadump is present in Sun Solaris JVMs, much of the content of the javacore is added by IBM and, therefore, is present only in IBM JVMs. </span></p><p class="c1"><span class="c0">IBM Thread and Monitor Dump Analyzer for Java Technology analyzes javacore and diagnoses monitor locks and thread activities in order to identify the root cause of hangs, deadlocks, and resource contention or monitor bottlenecks. </span></p><p class="c1"><span class="c7 c4">How does it work?</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">This technology analyzes each thread information and provides diagnostic information, such as current thread information, the signal that caused the javacore, Java heap information (maximum Java heap size, initial Java heap size, garbage collector counter, allocation failure counter, free Java heap size, and allocated Java heap size), number of runnable threads, total number of threads, number of monitors locked, and deadlock information. </span></p><p class="c1"><span class="c0">In addition, IBM Thread and Monitor Dump Analyzer for Java Technology provides the recommended size of the Java heap cluster (applicable only to IBM SDK 1.4.2 and 1.3.1 SR7 or above) based on the heuristic analysis engine. </span></p><p class="c1"><span class="c0">IBM Thread and Monitor Dump Analyzer for Java Technology compares each javacore and provides process ID information for threads, time stamp of the first javacore, time stamp of the last javacore, number of garbage collections per minute, number of allocation failures per minute, time between the first javacore and the last javacore, number of hang suspects, and list of hang suspects. </span></p><p class="c1"><span class="c0">This technology also compares all monitor information in javacore and detects deadlock and resource contention or monitor bottlenecks, if there are any. </span></p><p class="c5"><span class="c2 c7 c8">Installation instructions</span><span class="c7 c11 c8">&nbsp;</span></p><p class="c3"><span class="c0">Unzip the file jcaNNN.zip. </span></p><p class="c3"><span class="c0">Unzip the file readmeNNN.zip and read the &quot;readme&quot; file. </span></p><p class="c5"><span class="c0">Run jcaNNN.jar with the Java Run-time Environment. (Note: NNN is the version number.) </span></p><p class="c1"><span class="c0">The following is an example of processing a javacore with IBM Thread and Monitor Dump Analyzer for Java Technology, Version 1.0.1, and about 500 MB of Java heap size: &lt;Java Runtime Environment path&gt;java -Xmx500m -jar jca101.jar </span></p><p class="c5"><span class="c6 c4">Which log file i have to use :</span><span class="c0">&nbsp;</span></p><p class="c3 c15"><span class="c0"></span></p><p class="c3 c15"><span class="c0"></span></p><p class="c5"><span class="c2 c7 c8">What is HeapRoots?</span><span class="c7 c11 c8">&nbsp;</span></p><p class="c1"><span class="c0">HeapRoots is a tool for debugging memory leaks in Java&trade; applications through analysis of &quot;heap dumps.&quot; </span></p><p class="c1"><span>The Java Virtual Machine (JVM) maintains a run-time data area (called a heap) for the allocation of all class instances and array objects. The heap storage for objects is automatically reclaimed by a storage management system known as the garbage collector. If an application requires more heap space than can be made available by the garbage collector, the JVM throws an </span><span class="c8">OutOfMemoryError.</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">HeapRoots analyses &quot;heap dumps,&quot; which are files (typically text files) containing information about the objects in the JVM garbage collected heap. Some IBM VMs (contained in the IBM Developer Kits for Windows&reg;, Java Edition) have the ability to produce heap dumps on demand; heap dumps can also be triggered by out-of-memory situations. </span></p><p class="c5"><span class="c4">How does it work?</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">HeapRoots loads these heap dump files and provides commands for analyzing the data. These commands run algorithms on the data or query for information about the data. HeapRoots provides a command-line interactive interface where one enters commands and gets results. Examples of analysis include the following: </span></p><p class="c3"><span class="c0">searching/filtering of individual objects </span></p><p class="c3"><span class="c0">summary/tabulation of the various types of objects </span></p><p class="c3"><span class="c0">statistics on heap address space (such as gaps between objects) </span></p><p class="c3"><span class="c0">inward and outward references of an object </span></p><p class="c3"><span class="c0">paths between two objects </span></p><p class="c3"><span class="c0">exploring the heap from source/root objects by following references </span></p><p class="c3"><span class="c0">calculation of objects reachable by an object </span></p><p class="c5"><span class="c0">calculation of objects kept alive by an object. </span></p><p class="c5"><span class="c6 c4">Which log file i have to use :</span><span class="c0">&nbsp;</span></p><p class="c3 c15"><span class="c0"></span></p><p class="c3 c15"><span class="c0"></span></p><h3 class="c10"><span class="c16 c7 c8">Tool # 6</span><span class="c9 c4">&nbsp;</span></h3><p class="c19"><span class="c16 c7 c8">IBM Database Connection Pool Analyzer for IBM WebSphere Application Server.</span><span class="c0">&nbsp;</span></p><p class="c19"><span class="c7 c8 c16">(jcp11.zip)</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c7 c4">What is Database Connection Pool Analyzer for IBM WebSphere Application Server?</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">This tool employs a heuristic analysis engine to help you resolve problems related to Java&trade; Database Connectivity (JDBC) connection pools and find JDBC connection leaks. </span></p><p class="c1"><span class="c0">JDBC is used by applications written in Java to define how a client accesses database resources. JDBC connection pooling enables one to improve the response time of any given application that requires connections, especially Web-based applications. For example, when a user makes a request to a resource over the Web, the resource accesses a data source. The total datastore overhead quickly rises when used in Web-based applications, resulting in performance deterioration. However, when connection pooling capabilities are used, Web applications are less affected. Performance improvements of up to 20 times can be made. </span></p><p class="c1"><span class="c0">With connection pooling, most user requests do not incur the overhead of creating a new connection because the data source can locate and use an existing connection from the pool of connections. When the request is satisfied and the response is returned to the user, the resource returns the connection to the connection pool for reuse. The overhead of a disconnection is avoided. Each user request incurs a fraction of the cost for connecting or disconnecting. After the initial resources are used to produce the connections in the pool, additional overhead is insignificant because the existing connections are reused. </span></p><p class="c1"><span class="c0">For example, if a JDBC connection pool is deployed incorrectly and JDBC connections are not released after use, applications may suffer hangs, resource starvation, and other connection problems. Database Connection Pool Analyzer for IBM WebSphere&reg; Application Server helps you analyze JDBC connection pool leaks and resolve JDBC connection pool-related problems, particularly when using WebSphere Application Server. </span></p><p class="c5 c15"><span class="c0"><br></span></p><p class="c5"><span class="c2 c7 c26">How does it work?</span><span class="c0">&nbsp;</span></p><p class="c5"><span class="c0">The tool analyzes JDBC connection pool manager traces and provides the following functions: </span></p><p class="c3"><span class="c0">analysis of JDBC data source </span></p><p class="c3"><span class="c0">analysis of JDBC connection pool configuration </span></p><p class="c3"><span class="c0">JDBC connection chart view </span></p><p class="c5"><span class="c0">Java stack trace view of getConnection method </span></p><p class="c5"><span class="c0">The tool performs the following: </span></p><p class="c3"><span class="c0">parses trace files for JDBC connection pool manager </span></p><p class="c3"><span class="c0">detects available JDBC data sources and configurations </span></p><p class="c3"><span class="c0">counts the number of waiters of connections and number of connections </span></p><p class="c3"><span class="c0">finds Java stack traces associated with JDBC connection leaks </span></p><p class="c5"><span class="c0">provides charts of JDBC connections for each JDBC data source. </span></p><p class="c5"><span><br></span><span class="c6 c4">Which log file i have to use :</span><span class="c0">&nbsp;</span></p><h3 class="c10"><span class="c7 c8">Tool # 7</span><span class="c4 c9">&nbsp;</span></h3><p class="c19 c15"><span class="c0"><br></span></p><p class="c5"><span class="c2 c7 c8">What is Trace Analyzer for WebSphere Application Server?</span><span class="c7 c11 c8">&nbsp;</span></p><p class="c1"><span class="c0">Trace Analyzer for WebSphere&reg; Application Server is a graphical environment for analyzing WebSphere trace logs in detail. It was developed at the Hursley Laboratory by members of the Transaction team in order to facilitate the diagnosis and analysis of problems in complex WebSphere deployments. </span></p><p class="c1"><span class="c0">WebSphere Application Server produces primary diagnostic information in the form of text-based trace logs. The trace logs are used throughout the product lifecycle to diagnose failures and confirm correct code execution. As WebSphere is deployed in increasingly complex environments, problems become more difficult to resolve; often the only way to do so is to create trace logs to show the sequence of events leading to the problem. </span></p><p class="c1"><span class="c0">This utility makes it relatively easy to read the diagnostic information, even when the user is not very familiar with the component being debugged or tested. </span></p><p class="c5"><span class="c7 c4">How does it work?</span><span class="c0">&nbsp;</span></p><p class="c1"><span class="c0">WebSphere Trace Analyzer provides an environment for formatting the traces from a variety of platforms into a common view, and it provides a number of analytical tools to make the task of analysis easier and quicker: </span></p><p class="c3"><span class="c0">Visual trace presentation </span></p><p class="c3"><span class="c0">Advanced navigational engine </span></p><p class="c3"><span class="c0">Nested search and filter support </span></p><p class="c3"><span class="c0">Dynamic call sequence analysis </span></p><p class="c3"><span class="c0">Call duration measurement </span></p><p class="c3"><span class="c0">Trace highlighting and mark-up </span></p><p class="c5"><span class="c0">Entry and exit record pairing </span></p><p class="c1"><span class="c0">This utility is written in Java&trade; and requires a Java Virtual Machine (JVM 1.3.1 or above). The package includes a self-contained JAR file and a sample trace file for demonstration. </span></p><p class="c5"><span class="c6 c4">Which log file i have to use :</span><span class="c0"><br></span></p><p class="c3 c15"><span class="c0"></span></p><p class="c3 c15"><span class="c0"></span></p><p class="c5 c15"><span class="c0"><br></span></p><p class="c5"><span class="c2 c26">websphere resources</span><span class="c2">&nbsp;</span></p><p class="c5"><span class="c16 c11 c8">What is that for war content? </span></p><p class="c5"><span class="c16 c6 c11 c8">Thread Pool</span><span class="c6 c11 c8">&nbsp;</span><span class="c11 c8">-- what is it? How to configure it? How to troubleshoot it?</span><span class="c0">&nbsp;</span></p><p class="c5"><span class="c23 c6 c11 c8">Application Server &rarr; Server &rarr; Web Container &rarr; Thread Pool</span><span class="c0">&nbsp;</span></p><p class="c5"><span class="c16 c6 c11 c8">JDBC connection Pool</span><span class="c6 c11 c8">&nbsp;</span><span class="c11 c8">-- what is it? How to configure it? How to troubleshoot it?</span><span class="c0">&nbsp;</span></p><p class="c5"><span class="c6 c11 c8 c23">JDBC Providers &rarr; JDBC Name &rarr; Data Sources &rarr; DataSourceName &rarr; Connection Pools</span><span class="c0">&nbsp;</span></p><p class="c5"><span class="c16 c11 c8">JVM memory Heap Usage</span><span class="c11 c8">&nbsp;-- what is it? How to configure it? How to troubleshoot it?</span><span class="c0">&nbsp;</span></p><p class="c5"><span class="c11 c8">(</span><span>Heap size (the memory space where the progam lives) </span><span class="c11 c8">) Minimum and Maximum configuration ...</span><span class="c0">&nbsp;</span></p><p class="c5"><span class="c16 c11 c8">CPU</span><span class="c11 c8">&nbsp;-- what is it? How to configure it? How to troubleshoot it?</span><span class="c0">&nbsp;</span></p><p class="c5 c15"><span class="c0"><br></span></p><p class="c5 c15"><span class="c0"><br></span></p><p class="c5 c15"><span class="c0"><br></span></p></body></html>